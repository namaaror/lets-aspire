{
  "version": 3,
  "sources": ["../../vue-facing-decorator/src/deco3/utils.ts", "../../vue-facing-decorator/src/utils.ts", "../../vue-facing-decorator/src/option/setup.ts", "../../vue-facing-decorator/src/option/computed.ts", "../../vue-facing-decorator/src/option/data.ts", "../../vue-facing-decorator/src/option/methodsAndHooks.ts", "../../vue-facing-decorator/src/optionBuilder.ts", "../../vue-facing-decorator/src/option/ref.ts", "../../vue-facing-decorator/src/option/watch.ts", "../../vue-facing-decorator/src/option/props.ts", "../../vue-facing-decorator/src/option/inject.ts", "../../vue-facing-decorator/src/option/provide.ts", "../../vue-facing-decorator/src/option/emit.ts", "../../vue-facing-decorator/src/option/vmodel.ts", "../../vue-facing-decorator/src/option/accessor.ts", "../../vue-facing-decorator/src/component.ts", "../../vue-facing-decorator/src/option/vanilla.ts", "../../vue-facing-decorator/src/custom/custom.ts", "../../vue-facing-decorator/src/mixins.ts", "../../vue-facing-decorator/src/index.ts"],
  "sourcesContent": ["import { obtainSlot } from '../utils'\nexport const Compatible: {\n    fakePrototype?: any,\n\n} = {\n\n}\nexport function compatibleClassDecorator(deco: Function) {\n    return function (arg: any, ctx?: DecoratorContext) {\n\n        if (ctx) {//stage 3\n\n            if (ctx.kind !== 'class') {\n                throw 'deco stage 3 class'\n            }\n            const proto = Compatible.fakePrototype ??= {}\n            const slot = obtainSlot(proto)\n            delete Compatible.fakePrototype\n\n            obtainSlot(arg.prototype, slot)\n            const ret = deco(arg)\n\n            return ret\n        }\n        else {\n\n            return deco(arg)\n        }\n    }\n}\n\nexport function compatibleMemberDecorator(deco: Function) {\n    return function (arg: any, ctx: DecoratorContext | string) {\n        if (typeof ctx === 'object') {//stage 3\n            const proto = Compatible.fakePrototype ??= {};\n            proto[ctx.name!] = arg\n            return deco(proto, ctx.name)\n        } else {\n            return deco(arg, ctx)\n        }\n    }\n}", "import { Base } from './index'\nimport type { BaseTypeIdentify } from './index'\nimport type { InjectConfig } from \"./option/inject\";\nimport type { EmitConfig } from \"./option/emit\";\nimport type { PropsConfig } from \"./option/props\";\nimport type { HookConfig } from \"./option/methodsAndHooks\";\nimport type { VModelConfig } from \"./option/vmodel\";\nimport type { WatchConfig } from \"./option/watch\";\nimport type { SetupConfig } from './option/setup'\nimport type { Record as CustomDecoratorRecord } from './custom/custom'\nimport type { RefConfig } from './option/ref';\nimport type { ProvideConfig } from './option/provide';\nimport { compatibleMemberDecorator } from './deco3/utils';\n\nconst SlotSymbol = Symbol('vue-facing-decorator-slot')\n\nexport type SlotMapTypes = {\n    vanilla: Map<string, boolean>\n    computed: Map<string, boolean>\n    provide: Map<string, ProvideConfig>\n    inject: Map<string, InjectConfig>\n    emit: Map<string, EmitConfig>\n    emits: Map<string, boolean>\n    props: Map<string, PropsConfig>\n    hooks: Map<string, HookConfig>\n    'v-model': Map<string, VModelConfig>\n    watch: Map<string, WatchConfig | WatchConfig[]>\n    ref: Map<string, RefConfig>\n    setup: Map<string, SetupConfig>\n    customDecorator: Map<string, CustomDecoratorRecord[]>\n}\n\nclass Slot {\n    master: any\n    constructor(master: any) {\n        this.master = master\n    }\n    names: Map<string, SlotMapTypes[keyof SlotMapTypes]> = new Map()\n    obtainMap<T extends keyof SlotMapTypes>(name: T): SlotMapTypes[T] {\n        let map = this.getMap(name)\n        if (!map) {\n            map = new Map()\n            this.names.set(name, map)\n        }\n        return map as SlotMapTypes[T]\n    }\n    getMap<T extends keyof SlotMapTypes>(name: T) {\n        const map = this.names.get(name)\n        return map as SlotMapTypes[T] | undefined\n    }\n    inComponent = false\n    cachedVueComponent: any = null\n}\n\nexport function makeSlot(obj: any, defaultSlot?: Slot): Slot {\n    if (getSlot(obj)) {\n        throw ''\n    }\n    if (defaultSlot) {\n        defaultSlot.master = obj\n    }\n    const slot = defaultSlot ?? new Slot(obj)\n\n    Object.defineProperty(obj, SlotSymbol, {\n        enumerable: false,\n        value: slot\n    })\n    return slot\n}\n\nexport function getSlot(obj: any): Slot | undefined {\n\n    return Object.getOwnPropertyDescriptor(obj, SlotSymbol)?.value\n}\n\nexport function obtainSlot(obj: any, defaultSlot?: Slot): Slot {\n\n    const slot = getSlot(obj)\n    if (slot) {\n        return slot\n    }\n\n    return makeSlot(obj, defaultSlot)\n}\n\nexport function makeObject(names: string[], obj: any) {\n    return names.reduce<Record<string, any>>((pv, cv) => {\n        pv[cv] = obj[cv]\n        return pv\n    }, {})\n}\n\nexport function toComponentReverse(obj: any) {\n    const arr: any[] = []\n    let curr = obj\n    do {\n        arr.unshift(curr)\n        curr = Object.getPrototypeOf(curr)\n    } while (curr.constructor !== Base && !getSlot(curr))\n    return arr\n}\n\nexport function getSuperSlot(obj: any) {\n    let curr = Object.getPrototypeOf(obj)\n\n    while (curr.constructor !== Base) {\n        const slot = getSlot(curr)\n        if (slot) {\n            return slot\n        }\n        curr = Object.getPrototypeOf(curr)\n    }\n    return null\n}\n\n/**\n * Exclude decorated names by a filter\n */\nexport function excludeNames(names: string[], slot: Slot, filter?: (mapName: string) => boolean) {\n    return names.filter(name => {\n        let currSlot: Slot | null = slot\n        while (currSlot != null) {\n            for (const mapName of currSlot.names.keys()) {\n                if (filter && !filter(mapName)) {\n                    continue\n                }\n                if (mapName === 'customDecorator') {\n                    const map = currSlot.obtainMap('customDecorator')\n                    if (map.has(name)) {\n                        if (map.get(name)!.every(ite=>!ite.preserve)) {\n                            return false\n                        } else {\n                            continue\n                        }\n                    }\n                }\n                const map = currSlot.names.get(mapName)!\n                if (map.has(name)) {\n                    return false\n                }\n            }\n            currSlot = getSuperSlot(currSlot.master)\n        }\n\n        return true\n    })\n}\n\n/**\n * Get own properties by a filter\n */\nexport function getValidNames(obj: any, filter: (des: PropertyDescriptor, name: string) => boolean) {\n    const descriptors = Object.getOwnPropertyDescriptors(obj)\n    return Object.keys(descriptors).filter(name => filter(descriptors[name], name))\n}\n\nexport function optionNullableMemberDecorator<T>(handler: { (proto: any, name: string, option?: T): any }) {\n    function decorator(option?: T): any\n    function decorator(proto: BaseTypeIdentify, name: any): any\n    function decorator(value: any, ctx: ClassMemberDecoratorContext): any //deco stage 3\n    function decorator(optionOrProto?: T | BaseTypeIdentify | any, name?: string | ClassMemberDecoratorContext): any {\n        if (name) {\n            compatibleMemberDecorator(function (proto: any, name: any) {\n                handler(proto, name)\n            })(optionOrProto, name)\n        }\n        else {\n            return compatibleMemberDecorator(function (proto: any, name: any) {\n                handler(proto, name, optionOrProto as T | undefined)\n            })\n        }\n    }\n\n    return decorator\n}\n\nexport function getProviderFunction(provide: any): () => {} {\n    if (typeof provide === 'function') return provide\n    return function () { return provide || {} }\n}\n", "import { compatibleMemberDecorator } from '../deco3/utils'\nimport type { OptionSetupFunction } from '../component'\nimport type { Cons } from '../component'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot } from '../utils'\n\nexport type SetupConfig = {\n    setupFunction: OptionSetupFunction\n}\n\nexport function decorator(setupFunction: OptionSetupFunction) {\n    return compatibleMemberDecorator(function (proto: any, name: string) {\n        const slot = obtainSlot(proto)\n        const map = slot.obtainMap('setup')\n        map.set(name, {\n            setupFunction\n        })\n    })\n}\n\nconst isPromise = (v: any): v is Promise<any> => v instanceof Promise\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    const slot = obtainSlot(cons.prototype)\n    const map = slot.getMap('setup')\n    if (!map || map.size === 0) {\n        return\n    }\n    const setup: OptionSetupFunction = function (props, ctx) {\n\n        const setupData: Record<string, any> = {};\n        let promises: Promise<any>[] | null = null;\n        for (const name of map.keys()) {\n\n            const setupState = map.get(name)!.setupFunction(props, ctx)\n\n            if (isPromise(setupState)) {\n                promises ??= []\n                promises.push(setupState.then((v) => {\n                    setupData[name] = v\n                }))\n            } else {\n                setupData[name] = setupState\n            }\n        }\n        if (Array.isArray(promises)) {\n            return Promise.all(promises).then(() => {\n                return setupData\n            })\n        } else {\n            return setupData\n        }\n    }\n\n    optionBuilder.setup = setup\n}\n", "import type { Cons } from '../component'\nimport { obtainSlot, toComponentReverse, getValidNames } from '../utils'\nimport type { OptionBuilder } from '../optionBuilder'\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    optionBuilder.computed ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const map = slot.obtainMap('computed')\n    const vanillaMap = slot.obtainMap('vanilla')\n    const protoArr = toComponentReverse(cons.prototype)\n    protoArr.forEach(proto => {\n        getValidNames(proto, (des, name) => {\n            return (typeof des.get === 'function' || typeof des.set === 'function') && !vanillaMap.has(name)\n        }).forEach(name => {\n\n            map.set(name, true)\n            const des = Object.getOwnPropertyDescriptor(proto, name)!\n            optionBuilder.computed![name] = {\n                get: typeof des.get === 'function' ? des.get : undefined,\n                set: typeof des.set === 'function' ? des.set : undefined\n            }\n        })\n    })\n}\n", "import type { Cons } from '../component'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { makeObject, obtainSlot, excludeNames, getValidNames } from '../utils'\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder, vueInstance: any) {\n    optionBuilder.data ??= {}\n    const sample = new cons(optionBuilder, vueInstance) as any\n    let names = getValidNames(sample, (des, name) => {\n        return !!des.enumerable\n            && !optionBuilder.methods?.[name]\n            && !optionBuilder.props?.[name]\n    })\n    const slot = obtainSlot(cons.prototype)\n    names = excludeNames(names, slot,(mapName) => {\n        //include these names:\n        //provide, user may access field directly\n        return !['provide'].includes(mapName)\n    })\n    Object.assign(optionBuilder.data, makeObject(names, sample))\n}\n", "import type { Cons } from '../component'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot, toComponentReverse, excludeNames, getValidNames, optionNullableMemberDecorator } from '../utils'\n\nexport const HookNames = [\n    \"beforeCreate\",\n    \"created\",\n    \"beforeMount\",\n    \"mounted\",\n    \"beforeUpdate\",\n    \"updated\",\n    \"activated\",\n    \"deactivated\",\n    \"beforeDestroy\",\n    \"beforeUnmount\",\n    \"destroyed\",\n    \"unmounted\",\n    \"renderTracked\",\n    \"renderTriggered\",\n    \"errorCaptured\",\n    \"serverPrefetch\",\n    \"render\"\n] as const\n\nexport type HookConfig = null\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('hooks');\n    map.set(name, null)\n})\n\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    const slot = obtainSlot(cons.prototype)\n    const protoArr = toComponentReverse(cons.prototype)\n    const map = slot.obtainMap('hooks')\n\n    optionBuilder.hooks ??= {}\n    optionBuilder.methods ??= {}\n    const HookFunctions: Record<string, Function> = {}\n    const MethodFunctions: Record<string, Function> = {}\n    protoArr.forEach(proto => {\n        let names = getValidNames(proto, (des, name) => {\n\n            if (name === 'constructor') {\n                return false\n            }\n            if (typeof des.value === 'function') {\n\n                return true\n            }\n            return false\n        })\n        names = excludeNames(names, slot, (mapName) => {\n            //include these names:\n            //watch, user may call watch method directly\n            //hooks, user may call hook method directly\n            //emits, user may have a method name which is same as one of event names\n            return !['watch', 'hooks', 'emits', 'provide'].includes(mapName)\n        });\n        names.forEach(name => {\n            if (HookNames.includes(name as any) || map.has(name)) {\n\n                HookFunctions[name] = proto[name]\n            }\n            else {\n                MethodFunctions[name] = proto[name]\n            }\n        })\n\n\n    })\n\n    Object.assign(optionBuilder.methods, MethodFunctions)\n    const beforeCreateCallbacks = [...optionBuilder.beforeCreateCallbacks ?? []]\n    if (beforeCreateCallbacks && beforeCreateCallbacks.length > 0) {\n        const oldBeforeCreateCallback = HookFunctions['beforeCreate']\n        HookFunctions['beforeCreate'] = function () {\n            beforeCreateCallbacks.forEach(callback => callback.apply(this, arguments))\n            if (oldBeforeCreateCallback) {\n                oldBeforeCreateCallback.apply(this, arguments)\n            }\n        }\n    }\n    Object.assign(optionBuilder.hooks, HookFunctions)\n\n}\n", "import type { WatchConfig } from './option/watch'\nimport type { PropsConfig } from './option/props'\nimport type { InjectConfig } from './option/inject'\nimport type { OptionSetupFunction } from './component'\nexport interface OptionBuilder {\n    name?: string\n    // setup?: (this: void, props: Readonly<any>, ctx: SetupContext<any>) => Promise<any> | any | RenderFunction | void\n    data?: Record<string, any>\n    methods?: Record<string, Function>\n    hooks?: Record<string, Function>\n    computed?: Record<string, any>\n    watch?: Record<string, WatchConfig | WatchConfig[]>\n    props?: Record<string, PropsConfig>\n    provide?: Record<string, any>\n    inject?: Record<string, InjectConfig>\n    setup?: OptionSetupFunction\n    beforeCreateCallbacks?: Function[]\n}\n\nexport function applyAccessors(optionBuilder: OptionBuilder, dataFunc: (ctx: any) => Map<string, { get: (() => any) | undefined, set: ((v: any) => any) | undefined }>) {\n    optionBuilder.beforeCreateCallbacks ??= []\n    optionBuilder.beforeCreateCallbacks.push(function (this: any) {\n        const ctx = this\n        const data = dataFunc(ctx)\n        data.forEach((v, n) => {\n            Object.defineProperty(ctx, n, v)\n        })\n    })\n}\n", "import type { Cons } from '../component'\nimport { type OptionBuilder, applyAccessors } from '../optionBuilder'\nimport { obtainSlot, optionNullableMemberDecorator } from '../utils'\n\nexport type RefConfig = null | string\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, key?: string) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('ref')\n    map.set(name, typeof key === 'undefined' ? null : key)\n})\n\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    const slot = obtainSlot(cons.prototype)\n\n    const names = slot.getMap('ref')\n    if (!names || names.size === 0) {\n        return\n    }\n\n    applyAccessors(optionBuilder, (ctx: any) => {\n        const data: Map<string, { get: () => any, set: undefined }> = new Map\n        names.forEach((value, name) => {\n            const refKey = value === null ? name : value\n            data.set(name, {\n                get: function (this: any) {\n                    return ctx.$refs[refKey]\n                },\n                set: undefined\n\n            })\n        })\n        return data\n    })\n\n}\n", "import type { Cons } from '../component'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot, } from '../utils'\nimport type { WatchCallback } from 'vue'\nimport { compatibleMemberDecorator } from '../deco3/utils'\nexport interface WatchConfig {\n    key: string\n    handler: WatchCallback,\n    flush?: 'post',\n    deep?: boolean,\n    immediate?: boolean,\n}\ntype Option = Omit<WatchConfig, 'handler' | 'key'>\nexport function decorator(key: string, option?: Option) {\n    return compatibleMemberDecorator(function (proto: any, name: string) {\n        const slot = obtainSlot(proto)\n        const map = slot.obtainMap('watch');\n        const opt = Object.assign({}, option ?? {}, {\n            key: key,\n            handler: proto[name]\n        })\n        if (map.has(name)) {\n            const t = map.get(name)!\n            if (Array.isArray(t)) {\n                t.push(opt)\n            } else {\n                map.set(name, [t, opt])\n            }\n        }\n        else {\n            map.set(name, opt)\n        }\n    })\n}\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    optionBuilder.watch ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.getMap('watch')\n    if (!names || names.size === 0) {\n        return\n    }\n\n    names.forEach((value, _name) => {\n        const values = Array.isArray(value) ? value : [value]\n        values.forEach(v => {\n            if (!optionBuilder.watch![v.key]) {\n                optionBuilder.watch![v.key] = v\n            } else {\n                const t = optionBuilder.watch![v.key]\n                if (Array.isArray(t)) {\n                    t.push(v)\n                } else {\n                    optionBuilder.watch![v.key] = [t, v]\n                }\n            }\n        })\n    })\n\n\n}\n", "import type { Cons } from '../component'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot, optionNullableMemberDecorator } from '../utils'\n\nexport interface PropsConfig {\n    type?: any\n    required?: boolean\n    default?: any\n    validator?(value: any): boolean;\n}\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, option?: PropsConfig) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('props')\n    const opt = Object.assign({}, option ?? {})\n    map.set(name, opt as PropsConfig)\n})\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    optionBuilder.props ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.getMap('props')\n    if (!names || names.size === 0) {\n        return\n    }\n\n    names.forEach((value, name) => {\n        optionBuilder.props![name] = value\n    })\n\n\n}\n\n\n", "import type { InjectionKey } from 'vue'\nimport type { Cons } from '../component'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot, optionNullableMemberDecorator } from '../utils'\n\nexport interface InjectConfig {\n    from?: string | symbol | Symbol | InjectionKey<any>\n    default?: any\n}\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, option?: InjectConfig) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('inject')\n    const opt = Object.assign({}, option ?? {})\n    map.set(name, opt)\n})\n\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    optionBuilder.inject ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.getMap('inject')\n    if (!names || names.size === 0) {\n        return\n    }\n\n    names.forEach((value, name) => {\n        optionBuilder.inject![name] = value\n    })\n\n}\n\n\n", "import type { Cons } from '../component';\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot, optionNullableMemberDecorator } from '../utils'\n\nexport type ProvideConfig = null | string\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, key?: ProvideConfig) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('provide')\n    map.set(name, typeof key === 'undefined' ? null : key)\n})\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder, vueInstance: any) {\n    optionBuilder.provide ??= {}\n    const sample = new cons(optionBuilder, vueInstance) as any\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.obtainMap('provide')\n    if (!names) return null\n    names.forEach((value, name) => {\n        const key = value === null ? name : value\n        optionBuilder.provide![key] = sample[name]\n    })\n}\n", "import type { Cons } from '../component'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot, optionNullableMemberDecorator } from '../utils'\nexport type EmitConfig = null | string\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, key?: string) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('emit');\n    map.set(name, typeof key === 'undefined' ? null : key)\n})\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    optionBuilder.methods ??= {}\n    const proto = cons.prototype\n    const slot = obtainSlot(proto)\n    const names = slot.getMap('emit')\n    if (!names || names.size === 0) {\n        return\n    }\n    const emits = slot.obtainMap('emits')\n    names.forEach((value, key) => {\n        const eventName = value === null ? key : value\n        emits.set(eventName, true)\n        optionBuilder.methods![key] = async function (this: any) {\n\n            const ret = proto[key].apply(this, arguments)\n            if (ret instanceof Promise) {\n                const proRet = await ret\n                this.$emit(eventName, proRet)\n            }\n            else {\n                this.$emit(eventName, ret)\n            }\n        }\n    })\n\n}\n", "import type { Cons } from '../component'\nimport type { OptionBuilder } from '../optionBuilder'\nimport { obtainSlot, optionNullableMemberDecorator } from '../utils'\nimport { decorator as PropsDecorator, type PropsConfig } from './props'\n\nexport type VModelConfig = PropsConfig & {\n    name?: string\n}\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string, option?: VModelConfig) {\n    option ??= {}\n    const slot = obtainSlot(proto)\n    let vmodelName = 'modelValue'\n    const propsConfig = { ...option }\n    if (propsConfig) {\n        vmodelName = propsConfig.name ?? vmodelName\n        delete propsConfig.name\n    }\n    PropsDecorator(propsConfig)(proto, vmodelName)\n    const map = slot.obtainMap('v-model')\n    map.set(name, option)\n})\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    optionBuilder.computed ??= {}\n    const slot = obtainSlot(cons.prototype)\n    const names = slot.getMap('v-model')\n    if (!names || names.size === 0) {\n        return\n    }\n    const emits = slot.obtainMap('emits')\n\n    names.forEach((value, name) => {\n        const vmodelName = (value && value.name) ?? 'modelValue'\n        const eventName = `update:${vmodelName}`\n        optionBuilder.computed![name] = {\n            get: function (this: any) {\n                return this[vmodelName]\n            },\n            set: function (val: any) {\n                this.$emit(eventName, val)\n            }\n        }\n        emits.set(eventName, true)\n    })\n\n}\n", "import type { Cons } from '../component'\nimport { type OptionBuilder, applyAccessors } from '../optionBuilder'\nimport { toComponentReverse, obtainSlot } from '../utils'\n\nexport function build(cons: Cons, optionBuilder: OptionBuilder) {\n    const slot = obtainSlot(cons.prototype)\n    const vanillaMap = slot.getMap('vanilla')\n    if (!vanillaMap || vanillaMap.size === 0) {\n        return\n    }\n    const protoArr = toComponentReverse(cons.prototype)\n    const map: Map<string, { get: (() => any) | undefined, set: ((v: any) => any) | undefined }> | undefined = new Map\n\n    applyAccessors(optionBuilder, (ctx: any) => {\n        protoArr.forEach(proto => {\n            const deses = Object.getOwnPropertyDescriptors(proto)\n            for (const name in deses) {\n                const des = deses[name]\n                if (des && vanillaMap.has(name)) {\n                    if (typeof des.get === 'function' || typeof des.set === 'function') {\n                        map.set(name, {\n                            set: typeof des.set === 'function' ? des.set.bind(ctx) : undefined,\n                            get: typeof des.get === 'function' ? des.get.bind(ctx) : undefined,\n                        })\n                    }\n                }\n            }\n        })\n        return map\n    })\n}\n", "import { defineComponent, type ComponentCustomOptions } from 'vue';\nimport { obtainSlot, getSuperSlot, getProviderFunction } from './utils'\nimport { build as optionSetup } from './option/setup'\nimport { build as optionComputed } from './option/computed'\nimport { build as optionData } from './option/data'\nimport { build as optionMethodsAndHooks } from './option/methodsAndHooks'\nimport { build as optionRef } from './option/ref'\nimport { build as optionWatch } from './option/watch'\nimport { build as optionProps } from './option/props'\nimport { build as optionInject } from './option/inject'\nimport { build as optionProvide } from './option/provide'\nimport { build as optionEmit } from './option/emit'\nimport { build as optionVModel } from './option/vmodel'\nimport { build as optionAccessor } from './option/accessor'\nimport type { SetupContext } from 'vue';\nimport type { OptionBuilder } from './optionBuilder'\nimport type { VueCons } from './index'\nimport * as DecoratorCompatible from './deco3/utils'\nexport type Cons = VueCons\n\ntype SetupFunction<T> = (this: void, props: Readonly<any>, ctx: SetupContext<any>) => T | Promise<T>\nexport type OptionSetupFunction = SetupFunction<any>\nexport type ComponentSetupFunction = SetupFunction<Record<string, any>>\nfunction ComponentOption(cons: Cons, extend?: any) {\n    const optionBuilder: OptionBuilder = {}\n    optionSetup(cons, optionBuilder)\n    optionVModel(cons, optionBuilder)\n    optionComputed(cons, optionBuilder)//after VModel\n    optionWatch(cons, optionBuilder)\n    optionProps(cons, optionBuilder)\n    optionInject(cons, optionBuilder)\n    optionEmit(cons, optionBuilder)\n    optionRef(cons, optionBuilder)//after Computed\n    optionAccessor(cons, optionBuilder)\n    optionMethodsAndHooks(cons, optionBuilder)//the last one\n    const raw = {\n        name: cons.name,\n        setup: optionBuilder.setup,\n        data() {\n            delete optionBuilder.data\n            optionData(cons, optionBuilder, this)\n            return optionBuilder.data ?? {}\n        },\n        methods: optionBuilder.methods,\n        computed: optionBuilder.computed,\n        watch: optionBuilder.watch,\n        props: optionBuilder.props,\n        inject: optionBuilder.inject,\n        provide() {\n            optionProvide(cons, optionBuilder, this)\n            return optionBuilder.provide ?? {}\n        },\n        ...optionBuilder.hooks,\n        extends: extend\n    }\n    return raw as any\n}\n\ntype ComponentOption = {\n    name?: string\n    emits?: string[]\n    provide?: Record<string, any> | Function\n    components?: Record<string, any>\n    directives?: Record<string, any>;\n    inheritAttrs?: boolean;\n    expose?: string[];\n    render?: Function;\n    modifier?: (raw: any) => any\n    options?: ComponentCustomOptions & Record<string, any>\n    template?: string\n    mixins?: any[]\n    setup?: ComponentSetupFunction\n}\n\ntype ComponentConsOption = Cons | ComponentOption\n\nfunction buildComponent(cons: Cons, arg: ComponentOption, extend?: any): any {\n    const option = ComponentOption(cons, extend)\n    const slot = obtainSlot(cons.prototype)\n    Object.keys(arg).reduce<Record<string, any>>((option, name: string) => {\n        if (['options', 'modifier', 'emits', 'setup', 'provide'].includes(name)) {\n            return option\n        }\n        option[name] = arg[name as keyof ComponentOption]\n        return option\n    }, option)\n\n    //apply event emits\n    let emits = Array.from(slot.obtainMap('emits').keys())\n    if (Array.isArray(arg.emits)) {\n        emits = Array.from(new Set([...emits, ...arg.emits]))\n    }\n    option.emits = emits\n\n    //merge setup function\n    if (!option.setup) {\n        option.setup = arg.setup\n    } else {\n\n        const oldSetup: OptionSetupFunction = option.setup\n        const newSetup: ComponentSetupFunction = arg.setup ?? function () { return {} }\n\n        const setup: ComponentSetupFunction = function (props, ctx) {\n            const newRet = newSetup(props, ctx)\n            const oldRet = oldSetup(props, ctx)\n            if (oldRet instanceof Promise || newRet instanceof Promise) {\n                return Promise.all([newRet, oldRet]).then((arr) => {\n                    const ret = Object.assign({}, arr[0], arr[1])\n                    return ret\n                })\n            } else {\n\n                const ret = Object.assign({}, newRet, oldRet)\n                return ret\n            }\n\n        }\n        option.setup = setup\n    }\n\n    //merge provide function\n    const oldProvider = getProviderFunction(option.provide)\n    const newProvider = getProviderFunction(arg.provide)\n    option.provide = function() {\n        return Object.assign({}, oldProvider.call(this), newProvider.call(this))\n    }\n\n    //custom decorator\n    const map = slot.getMap('customDecorator')\n    if (map && map.size > 0) {\n        map.forEach((v) => {\n            v.forEach(ite=>ite.creator.apply({}, [option, ite.key]))\n            \n        })\n    }\n\n    //shallow merge options\n    if (arg.options) {\n        Object.assign(option, arg.options)\n    }\n\n    //apply modifier\n    if (arg.modifier) {\n        arg.modifier(option)\n    }\n\n    return defineComponent(option)\n}\nfunction build(cons: Cons, option: ComponentOption) {\n    const slot = obtainSlot(cons.prototype)\n    slot.inComponent = true\n    const superSlot = getSuperSlot(cons.prototype)\n    if (superSlot) {\n        if (!superSlot.inComponent) {\n            throw 'Class should be decorated by Component or ComponentBase: ' + slot.master\n        }\n        if (superSlot.cachedVueComponent === null) {\n            throw 'Component decorator 1'\n        }\n    }\n    const component = buildComponent(cons, option, superSlot === null ? undefined : superSlot.cachedVueComponent)\n    component.__vfdConstructor = cons\n    slot.cachedVueComponent = component;\n    (cons as any).__vccOpts = component\n}\nfunction _Component(cb: (cons: Cons, option: ComponentOption) => any, arg: ComponentConsOption, ctx?: ClassDecoratorContext) {\n    if (typeof arg === 'function') {\n        return DecoratorCompatible.compatibleClassDecorator(function (cons: Cons) {\n            return cb(cons, {})\n        })(arg, ctx)\n    }\n    return DecoratorCompatible.compatibleClassDecorator(function (cons: Cons) {\n        return cb(cons, arg)\n    })\n}\nexport function ComponentBase(arg: ComponentConsOption, ctx?: ClassDecoratorContext): any {\n    return _Component(function (cons: Cons, option: ComponentOption) {\n        build(cons, option)\n        return cons\n    }, arg, ctx)\n}\n\nexport const Component = ComponentBase\n\nexport function toNative<T extends Cons>(cons: T): T {\n    const slot = obtainSlot(cons.prototype)\n    if (!slot.inComponent) {\n        throw 'to native 1'\n    }\n    const cached = slot.cachedVueComponent\n    if (!cached) {\n        throw 'to native 2'\n    }\n    return cached\n}\n", "import { obtainSlot, optionNullableMemberDecorator } from '../utils'\n\nexport const decorator = optionNullableMemberDecorator(function (proto: any, name: string) {\n    const slot = obtainSlot(proto)\n    const map = slot.obtainMap('vanilla')\n    map.set(name, true)\n})\n", "import { obtainSlot } from '../utils'\nimport { compatibleMemberDecorator } from '../deco3/utils'\ntype Creator = { (options: any, key: string): void }\nexport interface Record {\n    key: string\n    creator: Creator\n    preserve: boolean\n}\n\nexport function createDecorator(creator: Creator, opt?: {\n    preserve?: boolean\n}) {\n    return compatibleMemberDecorator(function (proto: any, key: string) {\n        const slot = obtainSlot(proto)\n        const map = slot.obtainMap('customDecorator')\n        if(!map.has(key)){\n            map.set(key,[])\n        }\n        const arr = map.get(key)!\n        arr.push({\n            key,\n            creator,\n            preserve: !!opt?.preserve\n        })\n\n    })\n}\n\n\n", "import { ComponentBase } from './component'\nimport { obtainSlot } from './utils'\nimport type { VueCons } from './index'\nimport { Vue } from './index'\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;\ntype MixedClass<Mixins extends VueCons[]> = UnionToIntersection<{ [index in keyof Mixins]: InstanceType<Mixins[index]> }[number]>\nexport function mixins<T extends VueCons[]>(...conses: T) {\n    class MixinsClass extends Vue {\n\n    }\n    ComponentBase({\n        mixins: conses.map((cons => obtainSlot(cons.prototype).cachedVueComponent))\n    })(MixinsClass)\n    return MixinsClass as any as VueCons<MixedClass<T>>\n}\n\n\n\n\n\n\n\n", "export { Component, ComponentBase } from './component'\nexport { decorator as Setup } from './option/setup'\nexport { decorator as Ref } from './option/ref'\nexport { decorator as Watch } from './option/watch'\nexport { decorator as Prop } from './option/props'\nexport { decorator as Provide } from './option/provide'\nexport { decorator as Inject } from './option/inject'\nexport { decorator as Emit } from './option/emit'\nexport { decorator as VModel, decorator as Model } from './option/vmodel'\nexport { decorator as Vanilla } from './option/vanilla'\nexport { decorator as Hook } from './option/methodsAndHooks'\nexport { createDecorator } from './custom/custom'\nexport { mixins } from './mixins'\nimport type { ComponentPublicInstance } from 'vue'\nimport type { OptionBuilder } from './optionBuilder'\n\nconst IdentifySymbol = Symbol('vue-facing-decorator-identify')\nexport interface BaseTypeIdentify {\n    [IdentifySymbol]: undefined\n}\nexport function TSX<Properties extends {} = {}, Events extends {} = {}>() {\n    type Bundle = Properties & { [index in keyof Events as `on${Capitalize<index & string>}`]: Events[index] extends Function ? Events[index] : { (param: Events[index]): any } }\n    return function <C extends VueCons>(cons: C) {\n        return cons as unknown as {\n            new(): Omit<ComponentPublicInstance<(InstanceType<C>['$props']) & Bundle>, keyof Bundle> & InstanceType<C>//& ComponentPublicInstance & BaseTypeIdentify\n        }\n    }\n}\n\nexport type VueCons<T = {}> = {\n    new(optionBuilder: OptionBuilder, vueInstance: any): ComponentPublicInstance & BaseTypeIdentify & T\n}\n\nexport const Base = class {\n    constructor(optionBuilder: OptionBuilder, vueInstance: any) {\n        const props = optionBuilder.props\n        if (props) {\n            Object.keys(props).forEach(key => {\n                (this as any)[key] = vueInstance[key];\n            })\n        }\n        const methods = optionBuilder.methods\n        if (methods) {\n            Object.keys(methods).forEach(key => {\n                (this as any)[key] = methods[key].bind(vueInstance)\n            })\n        }\n    }\n\n} as VueCons\n\nexport const Vue = Base\n\nexport { toNative } from './component'\n"],
  "mappings": "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",
  "names": ["map", "decorator", "name", "build", "build", "_a", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "decorator", "build", "_a", "build", "build", "option", "decorator"]
}
